/* SPDX-License-Identifier: GPL-2.0 */
/* Copyright (c), 2022, Kaneru Contributors */
#include <stddef.h>
#include <sys/errno.h>

static const char *errnum_strs[ERRNUM_COUNT] = {
    [EOK] = "no error",
    [E2BIG] = "argument list too long",
    [EACCES] = "permission denied",
    [EADDRINUSE] = "address in use",
    [EADDRNOTAVAIL] = "address not available",
    [EAFNOSUPPORT] = "address family not supported",
    [EAGAIN] = "resource unavailable, try again",
    [EALREADY] = "connection already in progress",
    [EBADF] = "bad file descriptor",
    [EBADMSG] = "bad message",
    [EBUSY] = "device or resource busy",
    [ECANCELED] = "operation canceled",
    [ECHILD] = "no child processes",
    [ECONNABORTED] = "connection aborted",
    [ECONNREFUSED] = "connection refused",
    [ECONNRESET] = "connection reset",
    [EDEADLK] = "resource deadlock would occur",
    [EDESTADDRREQ] = "destination address required",
    [EDOM] = "mathematics argument out of domain of function",
    [EDQUOT] = "reserved",
    [EEXIST] = "file exists",
    [EFAULT] = "bad address",
    [EFBIG] = "file too large",
    [EHOSTUNREACH] = "host is unreachable",
    [EIDRM] = "identifier removed",
    [EILSEQ] = "illegal byte sequence",
    [EINPROGRESS] = "operation in progress",
    [EINTR] = "interrupted function",
    [EINVAL] = "invalid argument",
    [EIO] = "i/o error",
    [EISCONN] = "socket is connected",
    [EISDIR] = "is a directory",
    [ELOOP] = "too many levels of symbolic links",
    [EMFILE] = "file descriptor value too large",
    [EMLINK] = "too many links",
    [EMSGSIZE] = "message too large",
    [EMULTIHOP] = "reserved",
    [ENAMETOOLONG] = "filename too long",
    [ENETDOWN] = "network is down",
    [ENETRESET] = "connection aborted by network",
    [ENETUNREACH] = "network unreachable",
    [ENFILE] = "too many files open in system",
    [ENOBUFS] = "no buffer space available",
    [ENODATA] = "no message is available on the stream head read queue",
    [ENODEV] = "no such device",
    [ENOENT] = "no such file or directory",
    [ENOEXEC] = "executable file format error",
    [ENOLCK] = "no locks available",
    [ENOLINK] = "reserved",
    [ENOMEM] = "not enough space",
    [ENOMSG] = "no message of the desired type",
    [ENOPROTOOPT] = "protocol not available",
    [ENOSPC] = "no space left on device",
    [ENOSR] = "no stream resources",
    [ENOSTR] = "not a stream",
    [ENOSYS] = "functionality not supported",
    [ENOTCONN] = "the socket is not connected",
    [ENOTDIR] = "not a directory or a symbolic link to a directory",
    [ENOTEMPTY] = "directory not empty",
    [ENOTRECOVERABLE] = "state not recoverable",
    [ENOTSOCK] = "not a socket",
    [ENOTSUP] = "not supported",
    [ENOTTY] = "inappropriate i/o control operation",
    [ENXIO] = "no such device or address",
    [EOPNOTSUPP] = "operation not supported on socket",
    [EOVERFLOW] = "value too large to be stored in data type",
    [EOWNERDEAD] = "previous owner died",
    [EPERM] = "operation not permitted",
    [EPIPE] = "broken pipe",
    [EPROTO] = "protocol error",
    [EPROTONOSUPPORT] = "protocol not supported",
    [EPROTOTYPE] = "protocol wrong type for socket",
    [ERANGE] = "result too large",
    [EROFS] = "read-only file system",
    [ESPIPE] = "invalid seek",
    [ESRCH] = "no such process",
    [ESTALE] = "reserved",
    [ETIME] = "stream ioctl() timeout",
    [ETIMEDOUT] = "connection timed out",
    [ETXTBSY] = "text file busy",
    [EWOULDBLOCK] = "operation would block",
    [EXDEV] = "cross-device link",
};

const char *kstrerror(int errnum)
{
    if(errnum < 0)
        errnum = -errnum;
    if(errnum > 0 && errnum < ERRNUM_COUNT)
        return errnum_strs[errnum];
    return NULL;
}
